# app/modules/wp_repair/workers/malware_scan_worker.py
from __future__ import annotations

import os
import json
from typing import Any, Dict

from redis import Redis

from app import create_app
from app.modules.wp_repair.db_audit import set_action_status, add_finding
from app.modules.wp_repair.modules.malware.scan import malware_scan_apply

print(
    "Worker loaded: "
    "app.modules.wp_repair.workers.malware_scan_worker.perform_wp_repair_malware_scan ready"
)


# ----------------------------------------------------------------------
# Redis helpers
# ----------------------------------------------------------------------
def _redis() -> Redis:
    redis_url = os.getenv("REDIS_URL") or "redis://127.0.0.1:6379/0"
    return Redis.from_url(redis_url)


def _ctx_key(action_id: str) -> str:
    return f"wp_repair:ctx:{action_id}"


# ----------------------------------------------------------------------
# RQ job entrypoint (WP-Repair ONLY)
# ----------------------------------------------------------------------
def perform_wp_repair_malware_scan(action_id: str) -> Dict[str, Any]:
    """
    RQ job entrypoint for WP-Repair malware scan.

    Reads worker context from Redis key:
      wp_repair:ctx:<action_id>

    Runs malware_scan_apply() and writes:
      - findings via add_finding(...)
      - final action status via set_action_status(...)

    IMPORTANT:
    - This worker is strictly isolated from the normal malware scan worker.
    """

    r = _redis()
    key = _ctx_key(action_id)

    raw = r.get(key)
    if not raw:
        # Context missing â†’ mark failed (best effort)
        try:
            app = create_app()
            with app.app_context():
                set_action_status(
                    action_id,
                    "failed",
                    error_json={"error": "missing worker context in redis"},
                )
        except Exception:
            pass
        return {"ok": False, "error": "missing worker context in redis"}

    ctx = json.loads(raw)

    app = create_app()
    with app.app_context():
        # --------------------------------------------------------------
        # mark running
        # --------------------------------------------------------------
        try:
            set_action_status(
                action_id,
                "running",
                meta_json={"fix_id": "malware_scan", "running": True},
            )
        except Exception:
            pass

        try:
            # ----------------------------------------------------------
            # OPTIONAL debug context finding (OFF by default)
            # ----------------------------------------------------------
            debug_context = bool(ctx.get("debug_context", False))
            if debug_context:
                try:
                    add_finding(
                        action_id,
                        path=ctx.get("start_path") or ctx.get("wp_root"),
                        severity="low",
                        kind="worker_context",
                        detail_json={
                            "queue": "wp_repair",
                            "wp_root": ctx.get("wp_root"),
                            "start_path": ctx.get("start_path"),
                            "max_files": ctx.get("max_files"),
                            "max_bytes": ctx.get("max_bytes"),
                            "yara_enabled": ctx.get("yara_enabled"),
                        },
                    )
                except Exception:
                    pass

            # ----------------------------------------------------------
            # RUN ACTUAL SCAN
            # ----------------------------------------------------------
            result = malware_scan_apply(
                ctx["host"],
                int(ctx["port"]),
                ctx["username"],
                ctx["password"],
                wp_root=ctx["wp_root"],
                action_id=action_id,
                start_path=ctx.get("start_path"),
                max_files=int(ctx.get("max_files") or 4000),
                max_bytes=int(ctx.get("max_bytes") or 2_000_000),
                yara_enabled=bool(ctx.get("yara_enabled", True)),
                connect_timeout=int(ctx.get("connect_timeout") or 15),
                op_timeout=int(ctx.get("op_timeout") or 20),
            )

            # ----------------------------------------------------------
            # FINAL STATUS DECISION
            # ----------------------------------------------------------
            counts = result.get("counts") or {}

            malicious = int(counts.get("malicious") or 0)
            suspicious = int(counts.get("suspicious") or 0)
            errors = int(counts.get("errors") or 0)

            if errors > 0 and (malicious > 0 or suspicious > 0):
                final_status = "partial"
            elif errors > 0:
                final_status = "partial"
            else:
                final_status = "applied"

            set_action_status(
                action_id,
                final_status,
                result_json=result,
                meta_json={
                    "fix_id": "malware_scan",
                    "counts": counts,
                },
            )

            return {
                "ok": True,
                "status": final_status,
                "counts": counts,
                "action_id": action_id,
            }

        except Exception as e:
            try:
                set_action_status(
                    action_id,
                    "failed",
                    error_json={"error": str(e)},
                )
            except Exception:
                pass
            return {"ok": False, "error": str(e), "action_id": action_id}

        finally:
            # ----------------------------------------------------------
            # cleanup redis context (best effort)
            # ----------------------------------------------------------
            try:
                r.delete(key)
            except Exception:
                pass
