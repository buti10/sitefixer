# app/modules/repair/sftp_ops.py
from __future__ import annotations
import posixpath, stat, base64
from typing import Dict, Any, List, Optional
from app.models_repair import RepairSession
from app.extensions import db

class SFTPUnavailable(Exception): ...
_get_client = None

def _client_by_sid(sid: str):
    global _get_client
    if _get_client is None:
        from app.scanner.sftp_adapter import get_client_by_sid as _get
        _get_client = _get
    cli = _get_client(sid)
    if not cli:
        raise SFTPUnavailable(f"SFTP session not found: {sid}")
    return cli

def _ensure_under_root(root: str, path: str) -> str:
    root_n = posixpath.normpath(root or "/")
    want   = posixpath.normpath(path or root_n)
    if not want.startswith("/"):
        want = posixpath.normpath(posixpath.join(root_n, want))
    # Sonderfall: root == "/"
    if root_n == "/":
        return want if want.startswith("/") else "/"
    # Clamp unterhalb von root
    if not (want == root_n or want.startswith(root_n + "/")):
        want = root_n
    return want

# ---------- robustes Listing ohne chdir ----------
def _listdir_with_fallback(cli, p: str):
    p = p or "/"
    if p == "/":
        cands = ["/", ".", "/.", "./."]
    else:
        base = p.rstrip("/")
        noslash = base.lstrip("/") or "."
        cands = [f"{base}/.", base, f"{noslash}/.", noslash, f"./{noslash}/.", f"./{noslash}"]
    last = None
    for c in cands:
        try:
            return cli.listdir_attr(c)
        except FileNotFoundError as e:
            last = e
            continue
    raise last or FileNotFoundError(p)

def list_dir(session_id: int, path: Optional[str]):
    s: RepairSession = db.session.get(RepairSession, session_id)
    if not s:
        return {"error": "session not found"}, 404
    target = _ensure_under_root(s.root, path or s.root)
    cli = _client_by_sid(s.sid)
    try:
        attrs = _listdir_with_fallback(cli, target)
        items: List[Dict[str, Any]] = []
        for f in attrs:
            mode = f.st_mode
            items.append({
                "name": f.filename,
                "type": "dir" if stat.S_ISDIR(mode) else "file" if stat.S_ISREG(mode) else "other",
                "size": int(getattr(f, "st_size", 0) or 0),
                "mode": oct(mode & 0o777),
                "mtime": int(getattr(f, "st_mtime", 0) or 0),
            })
        # Verzeichnisse zuerst, danach Name case-insensitive
        items.sort(key=lambda x: (x["type"] != "dir", x["name"].lower()))
        return {"path": target, "items": items}, 200
    except FileNotFoundError:
        return {"error": "path not found", "path": target}, 404

# ---------- Datei lesen ----------
def _open_with_fallback(cli, want: str):
    want = want or "/"
    if want == "/":
        raise FileNotFoundError("/")
    base = want.rstrip("/")
    noslash = base.lstrip("/") or "."
    for c in [base, noslash, f"./{noslash}"]:
        try:
            st = cli.stat(c)
            if stat.S_ISDIR(st.st_mode):
                raise IsADirectoryError(c)
            return cli.open(c, "rb"), st
        except FileNotFoundError:
            continue
    raise FileNotFoundError(want)

def read_file(session_id: int, path: str, max_bytes: int = 200_000):
    s: RepairSession = db.session.get(RepairSession, session_id)
    if not s:
        return {"error": "session not found"}, 404
    want = _ensure_under_root(s.root, path or s.root)
    cli = _client_by_sid(s.sid)
    try:
        fh, st = _open_with_fallback(cli, want)
    except IsADirectoryError:
        return {"error": "is directory"}, 400
    except FileNotFoundError:
        return {"error": "not found"}, 404
    with fh as f:
        data = f.read(max_bytes + 1)
    truncated = len(data) > max_bytes
    if truncated:
        data = data[:max_bytes]
    # Nur echte NUL-Bytes markieren als binär
    binary = b"\x00" in data
    if binary:
        return {
            "path": path,
            "binary": True,
            "base64": base64.b64encode(data).decode("ascii"),
            "truncated": truncated,
            "size_hint": int(getattr(st, "st_size", 0) or 0),
        }, 200
    try:
        text = data.decode("utf-8")
    except UnicodeDecodeError:
        text = data.decode("latin-1", errors="replace")
    return {
        "path": path,
        "binary": False,
        "text": text,
        "truncated": truncated,
        "size_hint": int(getattr(st, "st_size", 0) or 0),
        "mtime": int(getattr(st, "st_mtime", 0) or 0),
    }, 200
# ---------- rename / move ----------
def rename_path(session_id: int, src: str, dst: str):
    s: RepairSession = db.session.get(RepairSession, session_id)
    if not s:
        return {"error": "session not found"}, 404

    src_p = _ensure_under_root(s.root, src or s.root)
    dst_p = _ensure_under_root(s.root, dst or s.root)

    cli = _client_by_sid(s.sid)
    try:
        # paramiko kann posix_rename haben, wenn Server es unterstützt
        if hasattr(cli, "posix_rename"):
            cli.posix_rename(src_p, dst_p)
        else:
            cli.rename(src_p, dst_p)
        return {"ok": True, "src": src_p, "dst": dst_p}, 200
    except FileNotFoundError:
        return {"error": "not found", "src": src_p}, 404
    except Exception as e:
        return {"error": str(e), "src": src_p, "dst": dst_p}, 500


# ---------- mkdir ----------
def mkdir_path(session_id: int, path: str):
    s: RepairSession = db.session.get(RepairSession, session_id)
    if not s:
        return {"error": "session not found"}, 404

    p = _ensure_under_root(s.root, path or s.root)
    cli = _client_by_sid(s.sid)
    try:
        cli.mkdir(p)
        return {"ok": True, "path": p}, 200
    except FileExistsError:
        return {"ok": True, "path": p}, 200
    except Exception as e:
        return {"error": str(e), "
