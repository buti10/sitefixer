#malware_routes.py
# malware_routes.py (oben)
import os, json, uuid, datetime
import pymysql
from pymysql.cursors import DictCursor
from flask import Blueprint, request, jsonify, current_app, send_file, abort, Response, render_template
from redis import Redis
from rq import Queue
from app.malware_worker import perform_malware_scan
from urllib.parse import unquote
def _iso(v):
    return v.isoformat() if isinstance(v, (datetime.datetime, datetime.date)) else v

bp = Blueprint("malware", __name__, url_prefix="/api/malware")

def db():
    return pymysql.connect(
        host=os.getenv("DB_HOST","localhost"),
        user=os.getenv("DB_USER","root"),
        password=os.getenv("DB_PASS",""),
        database=os.getenv("DB_NAME","sitefixer"),
        cursorclass=DictCursor,
        autocommit=True,
        charset="utf8mb4"
    )

redis_conn = Redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379/0"))
q = Queue("scans", connection=redis_conn)



from urllib.parse import unquote

from urllib.parse import unquote

@bp.post("/start")
def start():
    data = request.get_json(force=True) or {}

    # required
    try:
        ticket_id = int(data["ticket_id"])
    except Exception:
        return jsonify({"message": "ticket_id fehlt/ungültig"}), 400

    # basics
    sid       = (data.get("sid") or "").strip() or str(uuid.uuid4())
    root_path = (data.get("root_path") or "/").strip() or "/"
    quick     = bool(data.get("quick"))
    overwrite = bool(data.get("overwrite_baseline"))

    # SFTP session (allow existing session without host)
    sftp = data.get("sftp") or {}
    host = (sftp.get("host") or "").strip()
    port = int(sftp.get("port") or 22)
    username    = (sftp.get("username") or "").strip()
    password    = sftp.get("password") or None
    private_key = sftp.get("private_key") or None
    root_from_sftp = sftp.get("root_path") or None
    if root_from_sftp:
        root_path = root_from_sftp

    with db() as conn, conn.cursor() as cur:
        cur.execute("SELECT 1 FROM sftp_sessions WHERE sid=%s LIMIT 1", (sid,))
        session_exists = cur.fetchone() is not None
        if not session_exists and not host:
            return jsonify({"message": "sftp.host fehlt (keine bestehende Session zur sid)"}), 400
        if host:
            cur.execute("""
                INSERT INTO sftp_sessions (sid, host, port, username, password, private_key, root_path)
                VALUES (%s,%s,%s,%s,%s,%s,%s)
                ON DUPLICATE KEY UPDATE
                  host=VALUES(host), port=VALUES(port), username=VALUES(username),
                  password=VALUES(password), private_key=VALUES(private_key), root_path=VALUES(root_path)
            """, (sid, host, port, username, password, private_key, root_path))

    # ---- customer fields ONLY from request (flat or customer.{...})
    src = data.get("customer") or {}
    def g(*keys, default=""):
        for k in keys:
            v = src.get(k) if isinstance(src, dict) else None
            if not v:
                v = data.get(k)
            if isinstance(v, (str, int, float)) and str(v).strip():
                return str(v).strip()
        return default

    raw_domain = g("domain", "website_url")
    domain = unquote(raw_domain).replace("https://", "").replace("http://", "").strip("/")

    customer = {
        "domain":        domain or "ohne Domain",
        "name":          g("name"),
        "email":         g("email"),
        "cms":           g("cms") or g("content_management_system"),
        "hoster":        g("hoster") or g("hosting_provider"),
        "beschreibung":  g("beschreibung", "description"),
    }
    tz = (data.get("tz") or (src.get("tz") if isinstance(src, dict) else "") or "Europe/Berlin").strip()

    patterns = current_app.config.get(
        "DEFAULT_PATTERNS_QUICK" if quick else "DEFAULT_PATTERNS_FULL",
        ["<?php", r"eval\(", r"base64_decode\("],
    )
    opts = {
        "sid": sid,
        "root_path": root_path,
        "quick": quick,
        "overwrite_baseline": overwrite,
        "customer": customer,
        "tz": tz,
    }

    scan_id = str(uuid.uuid4())
    with db() as conn, conn.cursor() as cur:
        cur.execute("""
            INSERT INTO scans
              (id, ticket_id, status, progress, summary, options, root, patterns,
               customer_name, customer_email, customer_domain, customer_cms, customer_hoster, tz)
            VALUES
              (%s, %s, 'queued', 0, %s, %s, %s, %s,
               %s, %s, %s, %s, %s, %s)
        """, (
            scan_id, ticket_id,
            json.dumps({"counts":{"total":0,"scanned":0,"clean":0,"suspicious":0,"malicious":0,"errors":0}}),
            json.dumps(opts),
            root_path,
            json.dumps(patterns),
            customer["name"], customer["email"], customer["domain"],
            customer["cms"], customer["hoster"], tz,
        ))

    jid = q.enqueue("app.malware_worker.perform_malware_scan", scan_id, job_timeout=60*60*2)
    current_app.logger.info("Enqueued scan %s as job %s", scan_id, jid.id)

    return jsonify({
        "id": scan_id,
        "ticket_id": ticket_id,
        "status": "queued",
        "progress": 0,
        "summary": {"counts":{"total":0,"scanned":0,"clean":0,"suspicious":0,"malicious":0,"errors":0}},
    }), 202


# malware_routes.py
@bp.delete("/scan/<scan_id>")
def delete_scan(scan_id: str):
    with db() as conn, conn.cursor() as cur:
        # Reports + Findings zum Scan mit löschen
        cur.execute("DELETE FROM reports  WHERE scan_id=%s", (scan_id,))
        cur.execute("DELETE FROM findings WHERE scan_id=%s", (scan_id,))
        cur.execute("DELETE FROM scans    WHERE id=%s", (scan_id,))
        deleted = cur.rowcount
    return jsonify({"ok": True, "deleted": deleted})


@bp.get("/history/<int:ticket_id>")
def history(ticket_id: int):
    with db() as conn, conn.cursor() as cur:
        cur.execute("""SELECT id,ticket_id,status,progress,summary,root,options
                              created_at,started_at,finished_at
                       FROM scans
                       WHERE ticket_id=%s
                       ORDER BY id DESC LIMIT 100""",(ticket_id,))
        rows = cur.fetchall()
    for r in rows:
        if r.get("summary"):
            try: r["summary"] = json.loads(r["summary"])
            except: pass
    return jsonify(rows), 200

@bp.post("/cancel/<scan_id>")
def cancel_scan(scan_id: str):
    """Scan abbrechen: Status in 'scans' auf 'canceled' setzen.
       Der Worker prüft regelmäßig und steigt dann sauber aus."""
    with db() as conn, conn.cursor() as cur:
        cur.execute("""
            UPDATE scans
            SET status='canceled', finished_at=NOW()
            WHERE id=%s AND status IN ('queued','running')
        """, (scan_id,))
        conn.commit()
        updated = cur.rowcount
    return jsonify({"ok": True, "updated": updated})



# malware_routes.py
@bp.get("/findings/<scan_id>")
def findings(scan_id: int):
    with db() as conn, conn.cursor() as cur:
        cur.execute("""SELECT id,path,severity,kind,detail,detected_at
                       FROM findings WHERE scan_id=%s
                       ORDER BY detected_at DESC, id DESC""", (scan_id,))
        rows = cur.fetchall()
        # detail von JSON-String nach dict wandeln
        for r in rows:
            val = r.get("detail")
            if isinstance(val, (bytes, str)):
                try:
                    r["detail"] = json.loads(val)
                except Exception:
                    pass
    return jsonify(rows), 200



@bp.get("/scan/<scan_id>")
def scan(scan_id):
    with db() as conn, conn.cursor() as cur:
        cur.execute("""
            SELECT id,ticket_id,status,progress,summary,options,
                   created_at,started_at,finished_at
            FROM scans WHERE id=%s
        """, (scan_id,))
        row = cur.fetchone() or {}

    # <<< NEU: JSON-Felder parsen
    if row.get("summary"):
        try: row["summary"] = json.loads(row["summary"])
        except: pass
    if row.get("options"):
        try: row["options"] = json.loads(row["options"])
        except: pass

    return jsonify(row), 200

# Liste der Scans, optional gefiltert per ticket_id
@bp.get("/scans")
def scans():
    tid = request.args.get("ticket_id", type=int)
    with db() as conn, conn.cursor() as cur:
        if tid is not None:
            cur.execute("""SELECT id,ticket_id,status,progress,summary,created_at,started_at,finished_at
                           FROM scans WHERE ticket_id=%s ORDER BY created_at DESC""", (tid,))
        else:
            cur.execute("""SELECT id,ticket_id,status,progress,summary,created_at,started_at,finished_at
                           FROM scans ORDER BY created_at DESC LIMIT 100""")
        rows = cur.fetchall()
    for r in rows:
        if r.get("summary"):
            try: r["summary"] = json.loads(r["summary"])
            except: pass
    return jsonify(rows), 200


def _counts_from(findings, counts_json):
    # Falls counts in scans_malware vorhanden → nutzen
    try:
        if counts_json:
            c = counts_json if isinstance(counts_json, dict) else json.loads(counts_json)
            if isinstance(c, dict):
                # normalisieren auf erwartete Keys
                return {
                    "total": int(c.get("total", c.get("files", 0) or 0)),
                    "clean": int(c.get("clean", 0)),
                    "suspicious": int(c.get("suspicious", c.get("medium", 0) or 0)),
                    "malicious": int(c.get("malicious", c.get("high", 0) or 0) + int(c.get("critical", 0))),
                }
    except Exception:
        pass
    # sonst aus Findings ableiten
    total = len(findings)
    sev = lambda v: (v or "").lower()
    malicious = sum(1 for x in findings if sev(x.get("severity")) in ("high","critical"))
    suspicious= sum(1 for x in findings if sev(x.get("severity")) == "medium")
    clean = 0  # nur Funde gezählt → clean nicht bekannt
    return {"total": total, "clean": clean, "suspicious": suspicious, "malicious": malicious}

def _scan_by_any_id(cur, scan_id):
    # zuerst: job_id (string), dann numerische id
    cur.execute("SELECT * FROM scans_malware WHERE job_id=%s LIMIT 1", (str(scan_id),))
    row = cur.fetchone()
    if row: return row
    if str(scan_id).isdigit():
        cur.execute("SELECT * FROM scans_malware WHERE id=%s LIMIT 1", (int(scan_id),))
        row = cur.fetchone()
    return row

@bp.get("/reports/by-ticket/<int:ticket_id>")
def reports_by_ticket(ticket_id: int):
    sql = """
        SELECT
            r.id           AS report_id,
            r.scan_id      AS scan_id,
            r.title        AS title,
            r.created_at   AS report_created_at,
            r.file_html    AS file_html,
            r.file_pdf     AS file_pdf,
            s.status       AS scan_status,
            s.started_at   AS started_at,
            s.finished_at  AS finished_at,
            s.summary      AS summary_json
        FROM reports r
        JOIN scans s ON BINARY s.id = BINARY r.scan_id
        WHERE s.ticket_id = %s
        ORDER BY r.created_at DESC
    """
    with db() as conn, conn.cursor() as cur:
        cur.execute(sql, (ticket_id,))
        rows = cur.fetchall()

    out = []
    for r in rows:
        # counts aus scans.summary
        counts = {"total":0,"clean":0,"suspicious":0,"malicious":0}
        try:
            sj = r.get("summary_json")
            if sj:
                sj = json.loads(sj) if isinstance(sj, str) else sj
                c = sj.get("counts") or {}
                counts = {
                    "total": int(c.get("total", 0)),
                    "clean": int(c.get("clean", 0)),
                    "suspicious": int(c.get("suspicious", 0)),
                    "malicious": int(c.get("malicious", 0)),
                }
        except Exception:
            pass

        url_html = url_pdf = None
        fh, fp = r.get("file_html"), r.get("file_pdf")
        if fh and isinstance(fh, str) and os.path.isfile(fh):
            url_html = f"/api/malware/reports/{r['report_id']}/html"
        if fp and isinstance(fp, str) and os.path.isfile(fp):
            url_pdf  = f"/api/malware/reports/{r['report_id']}/pdf"

        out.append({
            "id": r["report_id"],
            "scan_id": r["scan_id"],
            "title": r["title"] or f"Scan #{r['scan_id']}",
            "created_at": _iso(r.get("report_created_at")),
            "status": r.get("scan_status"),
            "started_at": _iso(r.get("started_at")),
            "finished_at": _iso(r.get("finished_at")),
            "counts": counts,
            "url_html": url_html,
            "url_pdf": url_pdf,
        })

    return jsonify(out)