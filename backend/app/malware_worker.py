#malware_worker.py
print("Worker loaded: app.malware_worker.perform_malware_scan ready")

import os, json, re, math, hashlib, traceback
from datetime import datetime
import pymysql
from pymysql.cursors import DictCursor
from paramiko import Transport, SFTPClient
from stat import S_ISDIR

# ---------------- DB helpers ----------------

DB = dict(
    host=os.getenv("DB_HOST","localhost"),
    user=os.getenv("DB_USER","root"),
    password=os.getenv("DB_PASS",""),
    database=os.getenv("DB_NAME","sitefixer"),
    cursorclass=DictCursor,
    autocommit=True,
    charset="utf8mb4"
)

def _db():
    return pymysql.connect(**DB)

def _u(scan_id, **fields):
    sets = ", ".join(f"{k}=%s" for k in fields)
    vals = list(fields.values()) + [scan_id]
    with _db() as conn, conn.cursor() as cur:
        cur.execute(f"UPDATE scans SET {sets} WHERE id=%s", vals)

def _is_canceled(scan_id: int) -> bool:
    with _db() as conn, conn.cursor() as cur:
        cur.execute("SELECT status FROM scans WHERE id=%s", (scan_id,))
        row = cur.fetchone() or {}
        return row.get("status") == "canceled"



def _summary(scan_id):
    with _db() as conn, conn.cursor() as cur:
        cur.execute("SELECT summary FROM scans WHERE id=%s",(scan_id,))
        row = cur.fetchone() or {}
    return json.loads(row["summary"]) if row and row.get("summary") else {"counts":{}}

def _summary_set(scan_id, s):
    with _db() as conn, conn.cursor() as cur:
        cur.execute("UPDATE scans SET summary=%s WHERE id=%s",(json.dumps(s), scan_id))

def _ins_finding(scan_id, path, severity, kind, detail):
    with _db() as conn, conn.cursor() as cur:
        cur.execute(
            "INSERT INTO findings(scan_id,path,severity,kind,detail) VALUES (%s,%s,%s,%s,%s)",
            (scan_id, path, severity, kind, json.dumps(detail))
        )

# ---------------- util ----------------

def _sha(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def _entropy(b: bytes) -> float:
    if not b:
        return 0.0
    from collections import Counter
    c = Counter(b)
    n = len(b)
    e = 0.0
    for v in c.values():
        p = v / n
        e -= p * math.log2(p)
    return e

def _line_and_snippet(text: str, offset: int | None):
    """Gibt (line, snippet) zurück; line 1-basiert. Nur die betroffene Zeile."""
    if not text or offset is None or offset < 0:
        return None, None
    line = text.count("\n", 0, offset) + 1
    start_line = text.rfind("\n", 0, offset) + 1
    end_line = text.find("\n", offset)
    if end_line == -1:
        end_line = len(text)
    snippet = text[start_line:end_line]
    if len(snippet) > 400:
        snippet = snippet[:400] + " …"
    return line, snippet

# ---------------- YARA (optional) ----------------

try:
    import yara
    _YARA = None
    yara_dir = os.getenv("YARA_RULES_DIR","/opt/sitefixer/yara")
    if os.path.isdir(yara_dir):
        files = {
            f"r{i}": os.path.join(yara_dir, fn)
            for i, fn in enumerate(os.listdir(yara_dir))
            if fn.endswith((".yara", ".yar"))
        }
        if files:
            _YARA = yara.compile(filepaths=files)
except Exception:
    _YARA = None

# ---------------- detection ----------------

# vordefinierte Regexe (mit finditer, damit wir offsets bekommen)
_REGEXES = [
    ("dangerous_functions", "high",
     re.compile(r'\b(eval|assert|system|shell_exec|exec|passthru|popen|proc_open|create_function)\b', re.I)),
    ("obfuscation", "high",
     re.compile(r'(base64_decode\(|gzinflate\(|str_rot13\(|preg_replace\(.*/e)', re.I)),
]

def _detect(content: bytes, path: str):
    """Gibt (finds:list[dict], text:str) zurück.
    Jeder Fund: {kind, severity, info, offset, match}"""
    out = []
    text = ""
    try:
        text = content.decode("utf-8", errors="ignore")
    except Exception:
        text = ""

    # Regex-basierte Findings
    for kind, sev, rgx in _REGEXES:
        for m in rgx.finditer(text):
            out.append({
                "kind": kind,
                "severity": sev,
                "info": f"{kind} match",
                "offset": m.start(),
                "match": m.group(0)
            })

    # Entropie
    ent = _entropy(content)
    if ent >= 7.5 and len(content) > 200:
        out.append({
            "kind": "high_entropy",
            "severity": "medium",
            "info": f"{ent:.2f}",
            "offset": None,
            "match": None
        })

    # YARA
    if _YARA:
        try:
            matches = _YARA.match(data=content)
            for m in matches or []:
                out.append({
                    "kind": "yara_match",
                    "severity": "high",
                    "info": m.rule,
                    "offset": None,
                    "match": None
                })
        except Exception:
            pass

    return out, text

# ---------------- SFTP ----------------

def _connect_by_sid(sid: str):
    with _db() as conn, conn.cursor() as cur:
        cur.execute(
            "SELECT host,port,username,password,private_key,root_path FROM sftp_sessions WHERE sid=%s",
            (sid,)
        )
        r = cur.fetchone()
    if not r:
        raise RuntimeError(f"SID {sid} nicht gefunden")
    t = Transport((r["host"], int(r["port"] or 22)))
    # (vereinfachte Auth) – Schlüssel-Auth optional ergänzen
    t.connect(username=r["username"], password=r.get("password") or None)
    sftp = SFTPClient.from_transport(t)
    return t, sftp, (r.get("root_path") or "/")

# ---------------- main worker ----------------

def perform_malware_scan(scan_id: str):
    t = None
    sftp = None
    try:
        # Scan auf running setzen
        _u(scan_id, status="running", started_at=datetime.utcnow(), progress=1)

        # Optionen laden
        with _db() as conn, conn.cursor() as cur:
            cur.execute("SELECT options FROM scans WHERE id=%s", (scan_id,))
            row = cur.fetchone() or {}
        opts = json.loads(row.get("options") or "{}")

        sid  = opts.get("sid")
        root = (opts.get("root_path") or "/")
        if not sid:
            raise RuntimeError("sid fehlt")

        # SFTP verbinden
        t, sftp, sid_root = _connect_by_sid(sid)
        if not root or root == "/":
            root = sid_root or "/"

        # rekursiv auflisten
        paths: list[str] = []

        def walk(p: str):
            try:
                for a in sftp.listdir_attr(p):
                    name = a.filename
                    full = (p.rstrip("/") + "/" + name) if p != "/" else ("/" + name)
                    if S_ISDIR(a.st_mode):
                        if name in (".git", "node_modules", "vendor", "storage", "cache"):
                            continue
                        walk(full)
                    else:
                        if full.endswith((
                            ".php", ".phtml", ".php5", ".js", ".htaccess", ".ico", ".txt", ".html",
                            ".css", ".json", ".svg", ".ini", ".conf", ".phar", ".zip", ".tar",
                            ".gz", ".dat", ".bin"
                        )):
                            paths.append(full)
            except Exception:
                # Versteckte/ungültige Ordner still überspringen
                pass

        walk(root)
        paths.sort()

        # Zähler vorbereiten
        total  = max(1, len(paths))
        counts = {"total": len(paths), "scanned": 0, "clean": 0, "suspicious": 0, "malicious": 0, "errors": 0}
        _summary_set(scan_id, {"counts": counts})

        # Dateien scannen
        for i, path in enumerate(paths, 1):
            # Cancel-Check (nur scans, keine Alt-Tabelle!)
            if _is_canceled(scan_id):
                _u(scan_id, status="canceled", progress=int(i / total * 100), finished_at=datetime.utcnow())
                _summary_set(scan_id, {"counts": counts})
                return

            prog = int(i / total * 100)
            try:
                # Datei lesen (bis 5MB; kleine komplett)
                with sftp.file(path, "rb") as f:
                    content = f.read(5 * 1024 * 1024)
                    try:
                        size = f.stat().st_size
                        if size <= 5 * 1024 * 1024:
                            f.seek(0)
                            content = f.read()
                    except Exception:
                        pass

                sha = _sha(content)
                finds, text = _detect(content, path)

                if finds:
                    # high -> malicious, sonst suspicious
                    sev_overall = "malicious" if any(fd["severity"] == "high" for fd in finds) else "suspicious"
                    for fd in finds:
                        line, snippet = _line_and_snippet(text, fd.get("offset"))
                        _ins_finding(
                            scan_id,
                            path,
                            "high" if fd["severity"] == "high" else "medium",
                            fd["kind"],
                            {"sha256": sha, "info": fd["info"], "line": line, "snippet": snippet},
                        )
                    if sev_overall == "malicious":
                        counts["malicious"] += 1
                    else:
                        counts["suspicious"] += 1
                else:
                    counts["clean"] += 1

            except Exception as e:
                counts["errors"] += 1
                _ins_finding(scan_id, path, "low", "read_error", {"error": str(e)})

            counts["scanned"] = i
            if i % 10 == 0 or prog >= 100:
                _u(scan_id, progress=prog)
                _summary_set(scan_id, {"counts": counts})

        # Ergebnisstatus
        status = "ok" if counts["malicious"] == 0 and counts["suspicious"] == 0 else "issues"
        _u(scan_id, status=status, progress=100, finished_at=datetime.utcnow())
        _summary_set(scan_id, {"counts": counts})

        # Auto-Report erzeugen
        try:
            from app.malware_reports import generate_report_for_scan
            rep_id = generate_report_for_scan(_db, scan_id, include_snippets=True)
            _u(scan_id, notes=f"auto-report created: {rep_id}")
        except Exception as e:
            _u(scan_id, notes=f"report generation failed: {e}")

    except Exception as e:
        _u(scan_id, status="failed", finished_at=datetime.utcnow(), notes=str(e) + "\n" + traceback.format_exc())
    finally:
        try:
            if sftp:
                sftp.close()
        except Exception:
            pass
        try:
            if t:
                t.close()
        except Exception:
            pass
