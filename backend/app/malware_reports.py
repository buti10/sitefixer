# app/malware_reports.py
import os
import uuid
import json
from datetime import datetime
from typing import Optional
from zoneinfo import ZoneInfo  # ganz oben importieren
import pymysql
from pymysql.cursors import DictCursor
from flask import Blueprint, send_file, jsonify, request
from jinja2 import Environment, FileSystemLoader

# =========================
# DB-Setup
# =========================
DB = dict(
    host=os.getenv("DB_HOST", "localhost"),
    user=os.getenv("DB_USER", "root"),
    password=os.getenv("DB_PASS", ""),
    database=os.getenv("DB_NAME", "sitefixer"),
    cursorclass=DictCursor,
    autocommit=True,
    charset="utf8mb4",
)

def _db():
    return pymysql.connect(**DB)

# =========================
# Pfade / Jinja
# =========================
TEMPLATE_DIR = "/var/www/sitefixer/templates"      # enthält report.html und ./assets/
REPORT_DIR   = "/var/www/sitefixer/reports"
os.makedirs(REPORT_DIR, exist_ok=True)

env = Environment(loader=FileSystemLoader(TEMPLATE_DIR), autoescape=True)

def _fromjson(v):
    try:
        if isinstance(v, str):
            return json.loads(v or "{}")
        return v or {}
    except Exception:
        return {}
env.filters["fromjson"] = _fromjson

def _jsonloads(s):
    try:
        return json.loads(s) if isinstance(s, str) else (s or {})
    except Exception:
        return {}

# =========================
# PDF (WeasyPrint) Helper
# =========================
def _pdf_from_html(html_string: str, base_url: str):
    """
    Liefert bytes bei Erfolg, None bei fehlender/defekter WeasyPrint.
    """
    try:
        from weasyprint import HTML  # lazy import
    except Exception:
        return None
    try:
        return HTML(string=html_string, base_url=base_url).write_pdf()
    except Exception:
        return None

# =========================
# Kernfunktion: Report bauen
# =========================
def generate_report_for_scan(db_conn_factory, scan_id: str,
                             include_snippets: bool = True,
                             title: Optional[str] = None,
                             notes: Optional[str] = None) -> str:
    def _to_dict(v):
        try:
            return json.loads(v) if isinstance(v, str) else (v or {})
        except Exception:
            return {}

    # --- Scan + Findings + (optional) Ticket laden ---
    with db_conn_factory() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM scans WHERE id=%s", (scan_id,))
        scan = cur.fetchone()
        if not scan:
            raise RuntimeError(f"scan {scan_id} not found")

        cur.execute("""
            SELECT id, path, severity, kind, detail, detected_at
            FROM findings
            WHERE scan_id=%s
            ORDER BY path, id
        """, (scan_id,))
        findings = cur.fetchall()

    # --- JSON-Felder/Counts ---
    opts    = _to_dict(scan.get("options"))
    summary = _to_dict(scan.get("summary"))
    counts  = summary.get("counts") or {
        "total": len(findings), "clean": 0, "suspicious": 0, "malicious": 0, "errors": 0
    }

    # --- Kundendaten aus DB-Spalten ODER options.customer ---
    ocust = _to_dict(opts.get("customer"))
    # Priorität: DB-Spalten > options.customer > leer
    domain = (scan.get("customer_domain") or ocust.get("domain") or "") \
                .replace("https://","").replace("http://","").strip("/")
    ticket_id = scan.get("ticket_id") or opts.get("ticket_id") or "-"

    ticket = {
        "id": ticket_id,
        "domain": domain or "ohne Domain",
        "name":   scan.get("customer_name")   or ocust.get("name")   or "",
        "email":  scan.get("customer_email")  or ocust.get("email")  or "",
        "cms":    scan.get("customer_cms")    or ocust.get("cms")    or "",
        "hoster": scan.get("customer_hoster") or ocust.get("hoster") or "",
        "beschreibung": ocust.get("beschreibung") or "",
    }

    # --- lokale Zeit (TZ aus Scan/Options, sonst Europe/Berlin) ---
    from zoneinfo import ZoneInfo
    tzname = (scan.get("tz") or opts.get("tz") or "Europe/Berlin").strip() or "Europe/Berlin"
    try:
        generated_at = datetime.now(ZoneInfo(tzname))
    except Exception:
        generated_at = datetime.utcnow()

    # --- Findings.detail robust parsen ---
    for f in findings:
        d = f.get("detail")
        if isinstance(d, (str, bytes)):
            try: d = json.loads(d)
            except Exception: d = {}
        f["detail"] = d or {}

    # --- Dateinamen/Pfade ---
    safe_domain = (domain or "ohne-domain").replace("/", "_")
    base = f"ticket-{ticket_id}__{safe_domain}__scan-{str(scan_id)[:8]}"
    html_path = os.path.join(REPORT_DIR, base + ".html")
    pdf_path  = os.path.join(REPORT_DIR, base + ".pdf")

    # --- Template rendern ---
    logo_rel = "assets/logo.png" if os.path.isfile(os.path.join(TEMPLATE_DIR, "assets", "logo.png")) else None
    tmpl = env.get_template("report.html")
    html = tmpl.render(
        logo=logo_rel,
        ticket=ticket,
        scan=scan,
        counts=counts,
        findings=findings,
        include_snippets=include_snippets,
        generated_at=generated_at,
    )

    # --- HTML/PDF schreiben ---
    with open(html_path, "w", encoding="utf-8") as f:
        f.write(html)

    base_url = f"file://{TEMPLATE_DIR}/"
    pdf_bytes = _pdf_from_html(html, base_url=base_url)
    if pdf_bytes:
        with open(pdf_path, "wb") as f:
            f.write(pdf_bytes)
    else:
        pdf_path = None

    # --- Report-DB-Eintrag ---
    rep_id = str(uuid.uuid4())
    with db_conn_factory() as conn, conn.cursor() as cur:
        cur.execute("""
            INSERT INTO reports (id, ticket_id, scan_id, title, notes, file_pdf, file_html, created_at)
            VALUES (%s,%s,%s,%s,%s,%s,%s,NOW())
        """, (
            rep_id,
            ticket_id,
            scan_id,
            title or f"Malware-Report Ticket #{ticket_id} – {domain or 'ohne Domain'}",
            notes or "",
            pdf_path,
            html_path,
        ))
    return rep_id







# =========================
# API
# =========================
bp  = Blueprint("reports",        __name__, url_prefix="/api/malware/reports")
bp2 = Blueprint("reports_legacy", __name__, url_prefix="/api/reports")

@bp.get("/<scan_id>")
def list_by_scan(scan_id):
    # Links nur ausgeben, wenn Datei existiert
    with _db() as conn, conn.cursor() as cur:
        cur.execute("""
            SELECT id, scan_id, title, created_at, file_pdf, file_html
            FROM reports
            WHERE scan_id=%s
            ORDER BY created_at DESC
        """, (scan_id,))
        rows = cur.fetchall()

    out = []
    for r in rows:
        item = {
            "id": r["id"],
            "scan_id": r["scan_id"],
            "title": r["title"],
            "created_at": r["created_at"],
        }
        if r.get("file_pdf") and os.path.isfile(r["file_pdf"]):
            item["url_pdf"] = f"/api/malware/reports/{r['id']}/pdf"
        if r.get("file_html") and os.path.isfile(r["file_html"]):
            item["url_html"] = f"/api/malware/reports/{r['id']}/html"
        out.append(item)
    return jsonify(out)

@bp2.post("")
def create_report_legacy():
    return create_report()

@bp.post("")
def create_report():
    data = request.get_json(force=True) or {}
    scan_id = data.get("scan_id")
    if not scan_id:
        return jsonify({"error": "scan_id fehlt"}), 400

    inc   = bool(data.get("include_snippets", True))
    title = (data.get("title") or "").strip() or None
    notes = (data.get("notes") or "").strip() or None

    rep_id = generate_report_for_scan(
        _db, scan_id, include_snippets=inc, title=title, notes=notes
    )
    return jsonify({"id": rep_id}), 201

@bp.delete("/<rep_id>")
def delete_report(rep_id):
    with _db() as conn, conn.cursor() as cur:
        cur.execute("SELECT file_pdf, file_html FROM reports WHERE id=%s", (rep_id,))
        row = cur.fetchone()
        if not row:
            return jsonify({"error": "not found"}), 404

        for p in (row.get("file_pdf"), row.get("file_html")):
            try:
                if p and os.path.isfile(p):
                    os.remove(p)
            except Exception:
                pass

        cur.execute("DELETE FROM reports WHERE id=%s", (rep_id,))

    return jsonify({"ok": True})

@bp2.delete("/<rep_id>")
def delete_report_legacy(rep_id):
    return delete_report(rep_id)

@bp.get("/<rep_id>/pdf")
def download_pdf(rep_id):
    with _db() as conn, conn.cursor() as cur:
        cur.execute("SELECT file_pdf FROM reports WHERE id=%s", (rep_id,))
        row = cur.fetchone()
    if not row or not row.get("file_pdf") or not os.path.isfile(row["file_pdf"]):
        return jsonify({"error": "not found"}), 404
    return send_file(row["file_pdf"], mimetype="application/pdf", as_attachment=True)

@bp2.get("/<rep_id>/pdf")
def download_pdf_legacy(rep_id):
    return download_pdf(rep_id)

@bp.get("/<rep_id>/html")
def download_html(rep_id):
    with _db() as conn, conn.cursor() as cur:
        cur.execute("SELECT file_html FROM reports WHERE id=%s", (rep_id,))
        row = cur.fetchone()
    if not row or not row.get("file_html") or not os.path.isfile(row["file_html"]):
        return jsonify({"error": "not found"}), 404
    return send_file(row["file_html"], mimetype="text/html", as_attachment=True)

@bp2.get("/<rep_id>/html")
def download_html_legacy(rep_id):
    return download_html(rep_id)
